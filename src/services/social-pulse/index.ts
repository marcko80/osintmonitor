// Social Pulse Service
import type { PulseBucketData, PulseTimeseriesResponse, SocialSignal, SocialPulseState, PulseTimeframe, PulseBucket, EmotionLabel, SocialSignalType, SignalSeverity } from '@/types/social-pulse';
import { getAssets, getFilteredMessages } from '@/services/social';
import type { SocialAsset } from '@/types/social';
const EMOTIONS: EmotionLabel[] = ['anger','fear','joy','sadness','surprise','disgust','neutral'];
let signals: SocialSignal[] = [];
export function loadPulseState(): SocialPulseState { try { const r=localStorage.getItem('osint-social-pulse-state'); return r?JSON.parse(r):{selectedAssetId:null,timeframe:'24h',bucket:'15m',lastUpdate:null}; } catch{return {selectedAssetId:null,timeframe:'24h',bucket:'15m',lastUpdate:null};} }
export function savePulseState(s: SocialPulseState): void { localStorage.setItem('osint-social-pulse-state',JSON.stringify(s)); }
export function getSignals(): SocialSignal[] { return signals; }
export function clearSignals(): void { signals=[]; }
export function acknowledgeSignal(id:string):void{const s=signals.find(x=>x.id===id);if(s)s.acknowledged=true;}
function hashCode(s:string):number{let h=0;for(let i=0;i<s.length;i++){h=((h<<5)-h+s.charCodeAt(i))|0;}return h;}
function mockSentiment(text:string):{label:'negative'|'neutral'|'positive';score:number;emotion:EmotionLabel}{const h=Math.abs(hashCode(text));const mod=h%100;const label=mod<25?'negative':mod<65?'neutral':'positive';const score=0.3+(h%70)/100;return{label,score:Math.min(score,1),emotion:EMOTIONS[h%EMOTIONS.length]};}
function polarityFromLabel(l:'negative'|'neutral'|'positive'):number{return l==='negative'?-1:l==='positive'?1:0;}
function tfMs(tf:PulseTimeframe):number{switch(tf){case '1h':return 3600000;case '6h':return 21600000;case '24h':return 86400000;case '7d':return 604800000;}}
function bMs(b:PulseBucket):number{switch(b){case '5m':return 300000;case '15m':return 900000;case '60m':return 3600000;}}
export function computePulseTimeseries(assetId:string,timeframe:PulseTimeframe,bucket:PulseBucket):PulseTimeseriesResponse|null{const assets=getAssets();const asset=assets.find(a=>a.id===assetId);if(!asset)return null;const messages=getFilteredMessages();const assetMsgs=messages.filter(m=>m.matchedAssetIds.includes(assetId));const now=Date.now();const tf=tfMs(timeframe);const bk=bMs(bucket);const start=now-tf;const numB=Math.ceil(tf/bk);const buckets:PulseBucketData[]=[];let totVol=0,totPulse=0,totNeg=0;const eCounts:Record<EmotionLabel,number>={} as any;EMOTIONS.forEach(e=>eCounts[e]=0);for(let i=0;i<numB;i++){const bStart=start+i*bk;const bEnd=bStart+bk;const bMsgs=assetMsgs.filter(m=>{const t=new Date(m.postedAt).getTime();return t>=bStart&&t<bEnd;});let avgP=0,wp=0,negC=0;let topE:EmotionLabel='neutral';const eBk:Record<EmotionLabel,number>={} as any;EMOTIONS.forEach(e=>eBk[e]=0);if(bMsgs.length>0){let pS=0,wS=0;bMsgs.forEach(m=>{const s=mockSentiment(m.text);const p=polarityFromLabel(s.label);pS+=p;wS+=p*s.score;if(s.label==='negative')negC++;eBk[s.emotion]++;eCounts[s.emotion]++;});avgP=pS/bMsgs.length;wp=Math.max(-1,Math.min(1,wS/bMsgs.length));topE=(Object.entries(eBk) as [EmotionLabel,number][]).sort((a,b)=>b[1]-a[1])[0][0];}else{wp=Math.sin(i*0.3)*0.05;}totVol+=bMsgs.length;totPulse+=wp;totNeg+=negC;buckets.push({timestamp:new Date(bStart).toISOString(),pulseValue:wp,volume:bMsgs.length,negShare:bMsgs.length>0?(negC/bMsgs.length)*100:0,emotionTop:topE,avgPolarity:avgP});}const domE=(Object.entries(eCounts) as [EmotionLabel,number][]).sort((a,b)=>b[1]-a[1])[0][0];checkSignals(asset,buckets);return{assetId,assetName:asset.name,timeframe,bucket,buckets,summary:{totalVolume:totVol,avgPulse:numB>0?totPulse/numB:0,maxZScore:maxZ(buckets),negShareAvg:totVol>0?(totNeg/totVol)*100:0,dominantEmotion:domE},lastUpdate:new Date().toISOString()};}
function maxZ(buckets:PulseBucketData[]):number{const v=buckets.map(b=>b.volume);const m=v.reduce((a,b)=>a+b,0)/(v.length||1);const s=Math.sqrt(v.reduce((a,x)=>a+(x-m)**2,0)/(v.length||1))||1;return Math.max(...v.map(x=>Math.abs((x-m)/s)));}
function checkSignals(asset:SocialAsset,buckets:PulseBucketData[]):void{const VZT=3.0;const NST=45;const v=buckets.map(b=>b.volume);const m=v.reduce((a,b)=>a+b,0)/(v.length||1);const s=Math.sqrt(v.reduce((a,x)=>a+(x-m)**2,0)/(v.length||1))||1;const lb=buckets[buckets.length-1];if(lb){const z=(lb.volume-m)/s;if(z>VZT)addSig('volume_spike',asset,z,VZT,'Volume spike: z='+z.toFixed(1));if(lb.negShare>NST){const sv:SignalSeverity=lb.negShare>70?'high':lb.negShare>55?'med':'low';addSig('sentiment_shift',asset,lb.negShare,NST,'Neg surge: '+lb.negShare.toFixed(0)+'%25',sv);}}}
function addSig(type:SocialSignalType,asset:SocialAsset,tv:number,th:number,msg:string,sev?:SignalSeverity):void{const id=type+'-'+asset.id+'-'+Date.now();if(signals.some(s=>s.type===type&&s.assetId===asset.id&&Date.now()-s.timestamp.getTime()<300000))return;signals.push({id,type,severity:sev||(tv>th*2?'high':tv>th*1.5?'med':'low'),assetId:asset.id,assetName:asset.name,message:msg,triggerValue:tv,threshold:th,timestamp:new Date(),acknowledged:false});}
